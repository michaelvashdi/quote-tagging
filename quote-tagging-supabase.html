<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Quote Tagging System - Collaborative</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body class="bg-gradient-to-br from-purple-50 to-blue-50 min-h-screen">
    <div id="app" class="p-6 max-w-6xl mx-auto"></div>

    <script>
        // ============= CONFIGURATION =============
        // Replace the placeholder below with your actual project values.
        // IMPORTANT: never commit service_role keys; only use anon/public keys in client code.
        const SUPABASE_URL = 'https://kdkhucclzohjospjpbvd.supabase.co';
        const SUPABASE_ANON_KEY = 'REPLACE_WITH_ANON_KEY';

        // Initialize Supabase client safely (supabase-js v2 via CDN exposes window.supabase)
        const _createClient = window.supabase?.createClient;
        const supabase = typeof _createClient === 'function'
            ? _createClient(SUPABASE_URL, SUPABASE_ANON_KEY)
            : null;

        if (!supabase) {
            console.warn('Supabase client not initialized. Check that @supabase/supabase-js loaded correctly.');
        }

        // ============= STATE =============
        let state = {
            currentUser: null,
            quotes: [],
            currentIndex: 0,
            currentTags: {
                emotions: [],
                lifeareas: [],
                needs: [],
                corequestions: []
            },
            view: 'login', // login, tagging, consensus, admin
            allUsers: [],
            consensusData: null,
            selectedQuoteForConsensus: null,
            isRendering: false
        };

        // ============= TAG SYSTEM =============
        const tagSystem = {
            emotions: {
                question: "What emotional states does this quote address?",
                tags: {
                    Scared: "Fear, anxiety, worry, panic, terror",
                    Sad: "Grief, heartbreak, depression, sorrow",
                    Angry: "Frustration, resentment, irritation, rage",
                    Lost: "Confused, directionless, uncertain",
                    Alone: "Lonely, isolated, disconnected",
                    Loving: "Feeling love, connected, warm",
                    Happy: "Joyful, content, grateful, celebrating",
                    Calm: "Peaceful, serene, tranquil, centered",
                    Hopeful: "Optimistic, inspired, encouraged",
                    Doubtful: "Uncertain, questioning, lacking confidence"
                },
                recommended: "2-3 tags"
            },
            lifeareas: {
                question: "What situations or life areas does this quote apply to?",
                tags: {
                    Relationship: "Romantic partnerships, dating, marriage",
                    Selfworth: "Self-esteem, identity, self-love",
                    Purpose: "Life direction, meaning, calling",
                    Spiritual: "Spiritual growth, enlightenment, awakening",
                    Loss: "Death, endings, grief, letting go",
                    NewBeginning: "Transitions, fresh starts, change",
                    Work: "Career, service, contribution",
                    Healing: "Recovery from pain, trauma, illness",
                    Family: "Parents, children, siblings, community",
                    InnerPeace: "Meditation, stillness, finding calm"
                },
                recommended: "2-4 tags"
            },
            needs: {
                question: "What does someone NEED when they read this quote?",
                tags: {
                    Comfort: "Reassurance, 'it's going to be okay'",
                    Motivation: "Encouragement to keep going",
                    Wisdom: "Understanding, insight, deeper truth",
                    Permission: "Validation, 'it's okay to feel this'",
                    Direction: "Guidance on what to do",
                    Perspective: "New way of seeing, reframe",
                    Acceptance: "Surrender, letting go, 'stop fighting'",
                    Strength: "Reminder of inner power, resilience"
                },
                recommended: "2-3 tags"
            },
            corequestions: {
                question: "What deep existential question does this quote answer?",
                tags: {
                    "Am I enough?": "Worthiness, adequacy, self-value",
                    "Will I be okay?": "Safety, survival, security, future",
                    "Does anyone care?": "Love, belonging, being seen",
                    "What's the point?": "Meaning, purpose, 'why am I here?'",
                    "Am I doing it right?": "Validation, correctness, approval",
                    "Why is this happening?": "Understanding suffering",
                    "How do I let go?": "Release, surrender, detachment",
                    "Who am I really?": "Identity, true self, authenticity"
                },
                recommended: "1-2 tags"
            }
        };

        // ============= AUTH FUNCTIONS =============
        async function login() {
            if (!supabase) { alert('Supabase not initialized'); return; }

            const usernameEl = document.getElementById('username');
            const passwordEl = document.getElementById('password');
            const username = usernameEl ? usernameEl.value.trim() : '';
            const password = passwordEl ? passwordEl.value : '';

            if (!username || !password) {
                alert('Please enter username and password');
                return;
            }

            try {
                const { data, error } = await supabase.auth.signInWithPassword({
                    email: username,
                    password
                });

                if (error && !data) {
                    console.warn('Auth sign in failed:', error.message);
                }

                const user = data?.user;
                if (user) {
                    const { data: appUser } = await supabase
                        .from('users')
                        .select('*')
                        .eq('id', user.id)
                        .maybeSingle();

                    state.currentUser = appUser || { username, id: user.id, role: 'tagger' };
                } else {
                    // Fallback to legacy users table (plaintext) - not recommended
                    const { data: row, error: rowErr } = await supabase
                        .from('users')
                        .select('*')
                        .eq('username', username)
                        .eq('password', password)
                        .maybeSingle();

                    if (rowErr || !row) {
                        alert('Invalid credentials');
                        return;
                    }
                    state.currentUser = row;
                }

                await loadQuotes();
                await loadUserProgress();
                state.view = 'tagging';
                render();
            } catch (err) {
                console.error('Login error', err);
                alert('Login failed. See console for details.');
            }
        }

        async function register() {
            if (!supabase) { alert('Supabase not initialized'); return; }

            const usernameEl = document.getElementById('regUsername');
            const passwordEl = document.getElementById('regPassword');
            const username = usernameEl ? usernameEl.value.trim() : '';
            const password = passwordEl ? passwordEl.value : '';

            if (!username || !password) {
                alert('Please enter username and password');
                return;
            }

            if (password.length < 6) {
                alert('Password must be at least 6 characters');
                return;
            }

            try {
                const { data, error } = await supabase.auth.signUp({
                    email: username,
                    password
                }, { data: { username } });

                if (error) {
                    console.error('Auth signUp error', error);
                    alert('Registration failed: ' + error.message);
                    return;
                }

                if (data?.user?.id) {
                    const { error: insertErr } = await supabase
                        .from('users')
                        .insert([{ id: data.user.id, username, role: 'tagger' }]);

                    if (insertErr) {
                        console.warn('Could not create users row:', insertErr.message);
                    }
                }

                alert('Registration successful! Please check email to confirm and then login.');
                render();
            } catch (err) {
                console.error('Register error', err);
                alert('Registration failed. See console for details.');
            }
        }

        function logout() {
            state.currentUser = null;
            state.view = 'login';
            state.quotes = [];
            state.currentIndex = 0;
            state.currentTags = { emotions: [], lifeareas: [], needs: [], corequestions: [] };
            render();
        }

        // ============= DATA FUNCTIONS =============
        async function loadQuotes() {
            if (!supabase) return;
            try {
                const { data, error } = await supabase
                    .from('quotes')
                    .select('*')
                    .order('created_at', { ascending: true });

                if (error) {
                    console.error('Error loading quotes:', error);
                    return;
                }

                state.quotes = Array.isArray(data) ? data : [];
            } catch (err) {
                console.error('loadQuotes error', err);
            }
        }

        async function loadUserProgress() {
            if (!state.currentUser || !supabase) return;

            const { data, error } = await supabase
                .from('user_tags')
                .select('*')
                .eq('user_id', state.currentUser.id);

            if (error) {
                console.error('Error loading progress:', error);
                return;
            }

            const taggedQuoteIds = new Set((data || []).filter(t => t.completed).map(t => t.quote_id));
            const firstUntagged = (state.quotes || []).findIndex(q => !taggedQuoteIds.has(q.id));

            if (firstUntagged !== -1) {
                state.currentIndex = firstUntagged;
                await loadQuoteTags(state.quotes[firstUntagged].id);
            } else if ((state.quotes || []).length > 0) {
                state.currentIndex = 0;
                await loadQuoteTags(state.quotes[0].id);
            }
        }

        async function loadQuoteTags(quoteId) {
            if (!state.currentUser || !supabase || !quoteId) return;

            const { data, error } = await supabase
                .from('user_tags')
                .select('*')
                .eq('quote_id', quoteId)
                .eq('user_id', state.currentUser.id)
                .maybeSingle();

            if (error) {
                console.error('Error loading quote tags:', error);
                return;
            }

            if (data) {
                state.currentTags = {
                    emotions: Array.isArray(data.emotions) ? data.emotions : [],
                    lifeareas: Array.isArray(data.lifeareas) ? data.lifeareas : [],
                    needs: Array.isArray(data.needs) ? data.needs : [],
                    corequestions: Array.isArray(data.corequestions) ? data.corequestions : []
                };
            } else {
                state.currentTags = { emotions: [], lifeareas: [], needs: [], corequestions: [] };
            }
        }

        async function saveCurrentQuote() {
            if (!supabase) return;
            const currentQuote = (state.quotes || [])[state.currentIndex];
            if (!currentQuote || !state.currentUser) return;

            const { error } = await supabase
                .from('user_tags')
                .upsert({
                    quote_id: currentQuote.id,
                    user_id: state.currentUser.id,
                    emotions: state.currentTags.emotions,
                    lifeareas: state.currentTags.lifeareas,
                    needs: state.currentTags.needs,
                    corequestions: state.currentTags.corequestions,
                    completed: true,
                    tagged_at: new Date().toISOString()
                }, { onConflict: 'quote_id,user_id' });

            if (error) {
                console.error('Error saving tags:', error);
                alert('Error saving tags. Please try again.');
                return;
            }

            state.currentTags = { emotions: [], lifeareas: [], needs: [], corequestions: [] };

            if (state.currentIndex < (state.quotes || []).length - 1) {
                state.currentIndex++;
            } else {
                state.currentIndex = 0;
            }

            await loadQuoteTags((state.quotes || [])[state.currentIndex]?.id);
            render();
        }

        async function loadConsensusData() {
            if (!supabase) return;
            const { data: users } = await supabase.from('users').select('*');
            state.allUsers = Array.isArray(users) ? users : [];

            const { data: allTags } = await supabase
                .from('user_tags')
                .select('*, quotes(*), users(username)')
                .eq('completed', true);

            state.consensusData = calculateConsensus(Array.isArray(allTags) ? allTags : []);
            render();
        }

        function calculateConsensus(allTags) {
            const quoteMap = {};

            (allTags || []).forEach(tag => {
                const quoteId = tag.quote_id;
                if (!quoteId) return;
                if (!quoteMap[quoteId]) {
                    quoteMap[quoteId] = {
                        quote: tag.quotes || {},
                        taggers: [],
                        consensus: {
                            emotions: {},
                            lifeareas: {},
                            needs: {},
                            corequestions: {}
                        }
                    };
                }

                quoteMap[quoteId].taggers.push({
                    username: tag.users?.username || 'unknown',
                    tags: {
                        emotions: Array.isArray(tag.emotions) ? tag.emotions : [],
                        lifeareas: Array.isArray(tag.lifeareas) ? tag.lifeareas : [],
                        needs: Array.isArray(tag.needs) ? tag.needs : [],
                        corequestions: Array.isArray(tag.corequestions) ? tag.corequestions : []
                    }
                });

                ['emotions', 'lifeareas', 'needs', 'corequestions'].forEach(dim => {
                    (Array.isArray(tag[dim]) ? tag[dim] : []).forEach(t => {
                        if (!quoteMap[quoteId].consensus[dim][t]) {
                            quoteMap[quoteId].consensus[dim][t] = 0;
                        }
                        quoteMap[quoteId].consensus[dim][t]++;
                    });
                });
            });

            return quoteMap;
        }

        function getConsensusStatus(count, totalTaggers) {
            const percentage = totalTaggers > 0 ? (count / totalTaggers) * 100 : 0;
            if (count >= 2) return { status: 'accepted', color: 'green', percentage };
            if (count === 1) return { status: 'needs-review', color: 'orange', percentage };
            return { status: 'rejected', color: 'red', percentage };
        }

        // ============= ADMIN FUNCTIONS =============
        async function importQuotesCSV() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.csv';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = async (event) => {
                    const text = event.target.result || '';
                    const lines = text.split('\n');
                    const quotesToInsert = [];

                    for (let i = 1; i < lines.length; i++) {
                        const line = lines[i].trim();
                        if (!line) continue;

                        const matches = line.match(/(?:^|,)(\"(?:[^\"]|\"\")*\"|[^,]*)/g);
                        if (!matches || matches.length < 1) continue;

                        const clean = matches.map(m => m.replace(/^,?\"?|\"?$/g, '').replace(/\"\"/g, '\"'));

                        quotesToInsert.push({
                            quote: clean[0],
                            author: clean[1] || 'Unknown',
                            source: clean[2] || ''
                        });
                    }

                    const { error } = await supabase
                        .from('quotes')
                        .insert(quotesToInsert);

                    if (error) {
                        alert('Error importing quotes: ' + (error.message || 'unknown'));
                    } else {
                        alert(`Successfully imported ${quotesToInsert.length} quotes!`);
                        await loadQuotes();
                        render();
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }

        async function exportConsensusCSV() {
            if (!state.consensusData) {
                await loadConsensusData();
            }

            let csv = 'quote,author,source,emotions,lifeareas,needs,corequestions,taggers_count,conflicts\n';

            Object.values(state.consensusData || {}).forEach(item => {
                const quote = item.quote || {};
                const taggerCount = Array.isArray(item.taggers) ? item.taggers.length : 0;

                const getConsensusTags = (dim) => {
                    return Object.entries(item.consensus[dim] || {})
                        .filter(([tag, count]) => count >= 2)
                        .map(([tag]) => tag)
                        .join(';');
                };

                const hasConflicts = Object.values(item.consensus || {}).some(dim =>
                    Object.values(dim || {}).some(count => count === 1)
                );

                const safe = (s) => (s || '').toString().replace(/"/g, '""');

                csv += '"' + safe(quote.quote) + '","' + safe(quote.author) + '","' + safe(quote.source) + '",';
                csv += '"' + safe(getConsensusTags('emotions')) + '","' + safe(getConsensusTags('lifeareas')) + '",';
                csv += '"' + safe(getConsensusTags('needs')) + '","' + safe(getConsensusTags('corequestions')) + '",' + taggerCount + ',' + (hasConflicts ? '1' : '0') + '\n';
            });

            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'consensus_export.csv';
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);
        }

        // ============= UI HELPERS =============
        function clearElement(el) {
            while (el.firstChild) el.removeChild(el.firstChild);
        }

        function createButton(label, classes, onClick) {
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = classes || 'px-3 py-1 rounded bg-gray-200';
            btn.textContent = label;
            if (typeof onClick === 'function') btn.addEventListener('click', onClick);
            return btn;
        }

        function toggleTag(dim, tag) {
            if (!dim || !tag) return;
            const arr = state.currentTags[dim] || [];
            const idx = arr.indexOf(tag);
            if (idx === -1) arr.push(tag); else arr.splice(idx, 1);
            state.currentTags[dim] = arr;
            render();
        }

        function renderLogin() {
            const app = document.getElementById('app');
            clearElement(app);

            const card = document.createElement('div');
            card.className = 'bg-white p-6 rounded shadow';

            const title = document.createElement('h1');
            title.className = 'text-2xl mb-4';
            title.textContent = 'Quote Tagging - Login';
            card.appendChild(title);

            const uname = document.createElement('input');
            uname.id = 'username';
            uname.placeholder = 'email@example.com';
            uname.className = 'border p-2 w-full mb-2';
            card.appendChild(uname);

            const pword = document.createElement('input');
            pword.id = 'password';
            pword.type = 'password';
            pword.placeholder = 'password';
            pword.className = 'border p-2 w-full mb-2';
            card.appendChild(pword);

            const btnRow = document.createElement('div');
            btnRow.className = 'flex gap-2';
            btnRow.appendChild(createButton('Login', 'bg-blue-600 text-white px-4 py-2 rounded', login));
            btnRow.appendChild(createButton('Register', 'bg-gray-600 text-white px-4 py-2 rounded', () => { state.view = 'register'; render(); }));
            card.appendChild(btnRow);

            app.appendChild(card);
        }

        function renderRegister() {
            const app = document.getElementById('app');
            clearElement(app);

            const card = document.createElement('div');
            card.className = 'bg-white p-6 rounded shadow';

            const title = document.createElement('h1');
            title.className = 'text-2xl mb-4';
            title.textContent = 'Register';
            card.appendChild(title);

            const uname = document.createElement('input');
            uname.id = 'regUsername';
            uname.placeholder = 'email@example.com';
            uname.className = 'border p-2 w-full mb-2';
            card.appendChild(uname);

            const pword = document.createElement('input');
            pword.id = 'regPassword';
            pword.type = 'password';
            pword.placeholder = 'password (min 6 chars)';
            pword.className = 'border p-2 w-full mb-2';
            card.appendChild(pword);

            const btnRow = document.createElement('div');
            btnRow.className = 'flex gap-2';
            btnRow.appendChild(createButton('Create Account', 'bg-green-600 text-white px-4 py-2 rounded', register));
            btnRow.appendChild(createButton('Back', 'bg-gray-600 text-white px-4 py-2 rounded', () => { state.view = 'login'; render(); }));
            card.appendChild(btnRow);

            app.appendChild(card);
        }

        function renderTagging() {
            const app = document.getElementById('app');
            clearElement(app);

            const header = document.createElement('div');
            header.className = 'flex justify-between items-center mb-4';

            const title = document.createElement('h1');
            title.className = 'text-2xl';
            title.textContent = 'Tagging Interface';
            header.appendChild(title);

            const controls = document.createElement('div');
            controls.className = 'flex gap-2 items-center';
            controls.appendChild(createButton('Save', 'bg-blue-600 text-white px-3 py-1 rounded', saveCurrentQuote));
            controls.appendChild(createButton('Logout', 'bg-gray-600 text-white px-3 py-1 rounded', logout));
            controls.appendChild(createButton('Consensus', 'bg-purple-600 text-white px-3 py-1 rounded', () => { state.view = 'consensus'; loadConsensusData(); }));
            header.appendChild(controls);

            app.appendChild(header);

            const currentQuote = (state.quotes || [])[state.currentIndex] || { quote: 'No quotes available', author: '', source: '' };

            const quoteCard = document.createElement('div');
            quoteCard.className = 'bg-white p-6 rounded shadow mb-4';

            const qText = document.createElement('p');
            qText.className = 'text-xl italic mb-2';
            qText.textContent = currentQuote.quote || '';
            quoteCard.appendChild(qText);

            const qMeta = document.createElement('div');
            qMeta.className = 'text-sm text-gray-600 mb-4';
            qMeta.textContent = (currentQuote.author ? currentQuote.author + ' — ' : '') + (currentQuote.source || '');
            quoteCard.appendChild(qMeta);

            Object.keys(tagSystem).forEach(dim => {
                const block = document.createElement('div');
                block.className = 'mb-4';

                const q = document.createElement('div');
                q.className = 'font-semibold mb-2';
                q.textContent = (tagSystem[dim]?.question) || dim;
                block.appendChild(q);

                const tagWrap = document.createElement('div');
                tagWrap.className = 'flex flex-wrap gap-2';

                Object.keys(tagSystem[dim]?.tags || {}).forEach(tag => {
                    const selected = (state.currentTags[dim] || []).indexOf(tag) !== -1;
                    const btn = createButton(tag, (selected ? 'bg-blue-600 text-white' : 'bg-gray-200') + ' px-3 py-1 rounded', () => toggleTag(dim, tag));
                    btn.title = tagSystem[dim].tags[tag] || '';
                    tagWrap.appendChild(btn);
                });

                block.appendChild(tagWrap);
                quoteCard.appendChild(block);
            });

            app.appendChild(quoteCard);
        }

        function renderConsensus() {
            const app = document.getElementById('app');
            clearElement(app);

            const header = document.createElement('div');
            header.className = 'flex justify-between items-center mb-4';
            const title = document.createElement('h1');
            title.className = 'text-2xl';
            title.textContent = 'Consensus View';
            header.appendChild(title);

            const controls = document.createElement('div');
            controls.className = 'flex gap-2 items-center';
            controls.appendChild(createButton('Back', 'bg-gray-600 text-white px-3 py-1 rounded', () => { state.view = 'tagging'; render(); }));
            controls.appendChild(createButton('Export CSV', 'bg-green-600 text-white px-3 py-1 rounded', exportConsensusCSV));
            header.appendChild(controls);
            app.appendChild(header);

            if (!state.consensusData || Object.keys(state.consensusData).length === 0) {
                const empty = document.createElement('div');
                empty.className = 'bg-white p-6 rounded shadow';
                empty.textContent = 'No consensus data available.';
                app.appendChild(empty);
                return;
            }

            Object.values(state.consensusData).forEach(item => {
                const card = document.createElement('div');
                card.className = 'bg-white p-4 rounded shadow mb-3';

                const q = document.createElement('div');
                q.className = 'font-semibold mb-1';
                q.textContent = item.quote?.quote || '';
                card.appendChild(q);

                const meta = document.createElement('div');
                meta.className = 'text-sm text-gray-600 mb-2';
                meta.textContent = (item.quote?.author ? item.quote.author + ' — ' : '') + (item.quote?.source || '');
                card.appendChild(meta);

                const dims = document.createElement('div');
                dims.className = 'grid grid-cols-2 gap-2';

                ['emotions', 'lifeareas', 'needs', 'corequestions'].forEach(dim => {
                    const dimBlock = document.createElement('div');
                    const header = document.createElement('div');
                    header.className = 'font-semibold';
                    header.textContent = dim;
                    dimBlock.appendChild(header);

                    const list = document.createElement('div');
                    Object.entries(item.consensus[dim] || {}).forEach(([tag, count]) => {
                        const el = document.createElement('div');
                        const status = getConsensusStatus(count, Array.isArray(item.taggers) ? item.taggers.length : 0);
                        el.textContent = `${tag} — ${count} (${Math.round(status.percentage)}%)`;
                        list.appendChild(el);
                    });

                    dimBlock.appendChild(list);
                    dims.appendChild(dimBlock);
                });

                card.appendChild(dims);
                app.appendChild(card);
            });
        }

        function render() {
            if (state.isRendering) return;
            state.isRendering = true;
            try {
                if (state.view === 'login') return renderLogin();
                if (state.view === 'register') return renderRegister();
                if (state.view === 'tagging') return renderTagging();
                if (state.view === 'consensus') return renderConsensus();
                // default
                renderLogin();
            } finally {
                state.isRendering = false;
            }
        }

        // Initial render
        document.addEventListener('DOMContentLoaded', () => {
            render();
        });
    </script>
</body>
</html>
